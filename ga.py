# -*- coding: utf-8 -*-
"""A1b.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ytF7s5jvQSiYkACFzGNlKO_OfTbGFqvk

# [A1b] N-Queen's Using ARIEL Solution

### Introduction

The goal of this assignment is to port the solution to the N-Queens problem using the ARIEL EC module.

In order to do that I started by creating a new file called n_queens.py inside src/ariel/ec and tried to recreate
the structure of an Evolutionary Algorithm present on other files like a004.py

Now that I have a valid solution, I will copy the solution here and describe step by step how to run the new EA with this notebook.
"""

# The first thing to do is import the libraries we need
# Third-party libraries
import numpy as np
import mujoco
from mujoco import viewer
import matplotlib.pyplot as plt
import os
import neat
import pprint
# import visualize


# Local libraries
from ariel.utils.renderers import video_renderer
from ariel.utils.video_recorder import VideoRecorder
from ariel.simulation.environments._simple_flat import SimpleFlatWorld
from ariel.body_phenotypes.robogen_lite.constructor import construct_mjspec_from_graph
from ariel.utils.random_morphology import new_robot
from ariel.simulation.tasks.targeted_locomotion import distance_to_target
from ariel.simulation.controllers.hopfs_cpg import HopfCPG

# import prebuilt robot phenotypes
from ariel.body_phenotypes.robogen_lite.prebuilt_robots.hungry_gecko import hungry_gecko

import time

# Standard library
import random
import numpy as np
from pydantic_settings import BaseSettings

# Rich libraries for console output
from rich.console import Console
from rich.traceback import install

# Database libraries
from typing import Literal

# Local libraries
from ariel.ec.a004 import EAStep, EA, Individual, Population

"""#### Define fitness function"""

# Evaluates the fitness of individuals in the population
# I am using the permutation representation for the N-Queens problem
# To evaluate fitness, I will count the number of queens that are not in conflict
# Two queens are in conflict if they are in the same row, column, or diagonal
# The maximum fitness is n, which occurs when no queens are attacking each other
def evaluate(population: Population) -> Population:
    """Calculate the fitness of the individuals in the population."""
    mujoco.set_mjcb_control(None) # DO NOT REMOVE
    
    # Initialise world
    # Import environments from ariel.simulation.environments
    world = SimpleFlatWorld()

    #new_robot_body = new_robot()
    new_robot_body = hungry_gecko()
    world.spawn(new_robot_body.spec)
    
    # Generate the model and data
    # These are standard parts of the simulation USE THEM AS IS, DO NOT CHANGE
    model = world.spec.compile()
    data = mujoco.MjData(model) # type: ignore

    # Initialise data tracking
    # to_track is automatically updated every time step
    # You do not need to touch it.
    geoms = world.spec.worldbody.find_all(mujoco.mjtObj.mjOBJ_GEOM)
    to_track = [data.bind(geom) for geom in geoms if "core" in geom.name]
    
    for ind in population:
        if ind.requires_eval:
            adjacency_list = {}

            # adjacency_list[0] = [1]
            # adjacency_list[1] = [0]
            # adjacency_list[2] = [3]
            # adjacency_list[3] = [2]
            # adjacency_list[4] = [5]
            # adjacency_list[5] = [4]
            # adjacency_list[6] = [7]
            # adjacency_list[7] = [6]

            for i in range(8):
                adjacency_list[i] = [(i + 1) % 8, (i - 1) % 8]  # Ring topology
            
            amplitudes = ind.genotype[0:8]
            alpha = ind.genotype[8:16]
            omega = ind.genotype[16:24]   
            phase_diff = ind.genotype[24]
            h = ind.genotype[25]

            # print("Genotype", ind.genotype)
            # time.sleep(60)
            
            # List to hold CPG instances
            cpgs = []

            for i in range(8):
                cpg = HopfCPG(A=amplitudes,
                        num_neurons=8, 
                        adjacency_list=adjacency_list,
                        dt=0.02, 
                        h=h, 
                        alpha=alpha,
                        omega=omega,
                        phase_diff=phase_diff 
                        )
                cpgs.append(cpg)

                # x, y = cpgs[i].simulate(1500)

                # plt.plot(y*cpgs[i].A, label=f'CPG')
                # plt.title('CPG Outputs Over Time')
                # plt.xlabel('Time Steps')
                # plt.ylabel('Output')
                # plt.legend()
                # plt.show()


                # print("Genotype", ind.genotype)

                # time.sleep(60)

            for i in range(10000):
                moves = []
                for cpg in range(len(cpgs)):
                    _, y = cpgs[cpg].step()
                    moves.append(y[cpg])

                # print("Moves Before:", moves)
                if i % 100 == 0:
                    moves = np.deg2rad(np.array(moves) * 90.0)
                    # print("Moves:", moves)
                    data.ctrl = np.clip(moves, -np.pi/2, np.pi/2)
                    mujoco.mj_step(model, data)  # Step the simulation

            # print("Final Position:", self.core.xpos)
            
            # ind.fitness = distance_to_target((to_track[0].xpos[0], to_track[0].xpos[1]), (1.0, 0.0))
            ind.fitness = to_track[0].xpos[0].copy()
            # if ind.fitness > 8.0:
            #     print("Genome Fitness:", ind.fitness)
            #     time.sleep(60)
            mujoco.mj_resetData(model, data)  # Reset simulatio
            ind.requires_eval = False

    # Sort population by fitness in descending order
    # Higher fitness is better, so we want the best individuals at the front of the list
    # This is important for survivor selection
    population.sort(key=lambda x: x.fitness, reverse=True)

    # I am also printing the average fitness of the population for monitoring purposes
    print("Average fitness:", sum(ind.fitness for ind in population)/len(population))

    return population

"""#### Initialize the global constants"""

# Global constants
SEED = 42
DB_HANDLING_MODES = Literal["delete", "halt"]

# Global functions
install()
console = Console()
RNG = np.random.default_rng(SEED)

"""### Initialize the EASettings class.

The EASettings class holds important parameters of the EA. For example, I have used a target_population_size=100 and nqueens_dimension=64, meaning that this algorithm tries to solve a 64-queen board. The initial_population is 100.
"""

class EASettings(BaseSettings):
    quiet: bool = False

    # EC mechanisms
    is_maximisation: bool = True
    first_generation_id: int = 0
    num_of_generations: int = 10
    target_population_size: int = 20
    crossover_rate: float = 0.8
    mutation_rate: float = 0.25
    initial_population: int = 20

    # Genotype Constraints
    amplitude_max: float = 2*np.pi
    amplitude_min: float = 0.0
    alpha_max: float = 1.0
    alpha_min: float = 0.1
    omega_max: float = np.pi/4
    omega_min: float = np.pi/8
    phase_diff_max: float = np.pi
    phase_diff_min: float = 0.0
    h_max: float = 1.0
    h_min: float = 0.0

config = EASettings()

"""#### EA Steps (operators)

Now that we have loaded the global parameters and config, we can define the operators like 'parent_selection', 'crossover', 'mutation' and 'survival_selection'. I have also created a helper function called 'crossover_helper' in order to extract the logic of the crossover operator and keep it readable. The function 'visualize_solution' prints the best board configuration found at the end of the run.
"""

# ------------------------ EA STEPS ------------------------ #

def clip(value, parameter):
    if parameter == "AMPLITUDE":
        value = np.clip(value, a_min=config.amplitude_min, a_max=config.amplitude_max)
    elif parameter == "ALPHA":
        value = np.clip(value, a_min=config.alpha_min, a_max=config.alpha_max)
    elif parameter == "OMEGA":
        value = np.clip(value, a_min=config.omega_min, a_max=config.omega_max)
    elif parameter == "PHASE":
        value = np.clip(value, a_min=config.phase_diff_min, a_max=config.phase_diff_max)
    elif parameter == "H":
        value = np.clip(value, a_min=config.h_min, a_max=config.h_max)

    return value

def mutate(genotype, min, max, parameter):
    mu, sigma = 0, 0.1 # mean and standard deviation

    if isinstance(genotype, float):
        if np.random.rand() < config.mutation_rate:
            gen = clip(genotype + np.random.normal(mu, sigma, 1), parameter)

    else:
        for gen in genotype:
            if np.random.rand() < config.mutation_rate:
                gen = clip(gen + np.random.normal(mu, sigma, 1), parameter)

    return genotype

def mutation(population: Population) -> Population:
    """Apply mutation to an individual."""
    genotype_parts = ["AMPLITUDE", "ALPHA", "OMEGA", "PHASE", "H"]

    for ind in population:
        # Checks if mutation occurs based on mutation_rate
        if ind.tags.get("mut") == True:
            # Choose one of the 5 parts of the genotype to mutate
            chosen_part = genotype_parts[np.random.randint(4)]
            if chosen_part == "AMPLITUDE":
                ind.genotype[0:8] = mutate(ind.genotype[0:8], config.amplitude_min, config.amplitude_max, chosen_part)
            elif chosen_part == "ALPHA":
                ind.genotype[8:16] = mutate(ind.genotype[8:16], config.alpha_min, config.alpha_max, chosen_part)
            elif chosen_part == "OMEGA":
                ind.genotype[16:24] = mutate(ind.genotype[16:24], config.omega_min, config.omega_max, chosen_part)
            elif chosen_part == "PHASE":
                ind.genotype[24] = mutate(ind.genotype[24], config.phase_diff_min, config.phase_diff_max, chosen_part)
            elif chosen_part == "H":
                ind.genotype[25] = mutate(ind.genotype[25], config.h_min, config.h_max, chosen_part)

    return population

def survivor_selection(population: Population) -> Population:
    """Select the survivors, for the population of the next generation. Returns a list of survivors and their fitness values."""
    # Sort current population by fitness in descending order
    population.sort(key=lambda x: x.fitness, reverse=True)

    selected = list(population[0:10])

    for ind in population:
        if ind not in selected:
            ind.alive = False

    while len(selected) < config.target_population_size:
        selected.append(create_individual())

    return selected


def create_individual(genotype=None) -> Individual:
    ind = Individual()

    # Create a random permutation of numbers from 0 to num_of_dims-1 if no genotype is provided
    if genotype:
        ind.genotype = genotype
    else:
        # Genotype is a list of 26 real numbers 
        # First 8 are the amplitudes
        # Next 8 are the alphas
        # Next 8 are the omegas
        # Last 2 are phase_diff and h
        ind.genotype = np.zeros(26, dtype=float).tolist()
        ind.genotype[0:8] = np.random.uniform(low=config.amplitude_min, high=config.amplitude_max, size=8)
        ind.genotype[8:16] = np.random.uniform(low=config.alpha_min, high=config.alpha_max, size=8)
        ind.genotype[16:24] = np.random.uniform(low=config.omega_min, high=config.omega_max, size=8)
        ind.genotype[24] = np.random.uniform(low=config.phase_diff_min, high=config.phase_diff_max, size=1)[0]
        ind.genotype[25] = np.random.uniform(low=config.h_min, high=config.h_max, size=1)[0]

    ind.requires_eval = True
    ind.tags = {"mut": True}

    return ind

"""### Define evolutionary loop

Now that I have defined all necessary operators, we can define the evolutionary loop and run the algorithm.

"""

def main() -> None:
    """Entry point."""
    # Create initial population
    population_list = [create_individual() for _ in range(config.initial_population)]
    population_list = evaluate(population_list)


    # Create EA steps
    ops = [
        # EAStep("parent_selection", parent_selection),
        # EAStep("crossover", crossover),
        EAStep("mutation", mutation),
        EAStep("evaluation", evaluate),
        EAStep("survivor_selection", survivor_selection),
    ]

    # Initialize EA
    ea = EA(
        population_list,
        operations=ops,
        num_of_generations=10,
    )

    ea.run()

    best = ea.get_solution(only_alive=True, mode="best")

    console.log(best)

    # Visualize the best solution
    print(best.genotype)

if __name__ == "__main__":
    main()